package project.component;

import java.awt.Color;
import java.awt.GradientPaint;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.image.BufferedImage;
import java.beans.PropertyChangeSupport;

/**
 *
 * @author Dric
 */
public class ShadowPanel extends javax.swing.JPanel {

    private int shadowSize = 10; // Shadow thickness
    private Color shadowColor = new Color(0, 0, 0, 50); // Semi-transparent shadow color
    private BufferedImage shadowImage; // Cached shadow image

    private Color colorStart = Color.decode("#FFFFFF");  // Initial color 1
    private Color colorEnd = Color.decode("#D6D9DF");    // Initial color 2

    private final PropertyChangeSupport pcs = new PropertyChangeSupport(this);

    /**
     * Creates new form GradientPanel
     */
    public ShadowPanel() {
        initComponents();
        setOpaque(false);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 302, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 437, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    @Override
    protected void paintComponent(Graphics g) {
        Graphics2D graphics = (Graphics2D) g;
        graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        // Create shadow if not cached or size changed
        if (shadowImage == null || shadowImage.getWidth() != getWidth() || shadowImage.getHeight() != getHeight()) {
            shadowImage = createShadowImage();
        }

        // Draw shadow first
        graphics.drawImage(shadowImage, 0, 0, null);

        // Apply Gradient on top of the shadow
        GradientPaint gradient = new GradientPaint(0, 0, colorStart, 0, getHeight(), colorEnd);
        graphics.setPaint(gradient);
        graphics.fillRoundRect(shadowSize, shadowSize, getWidth() - 2 * shadowSize, getHeight() - 2 * shadowSize, 15, 15);

        super.paintComponent(g);
    }

    private BufferedImage createShadowImage() {
        int width = getWidth();
        int height = getHeight();
        BufferedImage shadow = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2 = shadow.createGraphics();

        // Set up rendering hints for smooth edges
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        // Draw shadow rectangle
        g2.setColor(shadowColor);
        g2.fillRoundRect(shadowSize, shadowSize, width - 2 * shadowSize, height - 2 * shadowSize, 15, 15);

        g2.dispose();

        // Apply blur effect
        return applyGaussianBlur(shadow, shadowSize);
    }

    private BufferedImage applyGaussianBlur(BufferedImage source, int radius) {
        int size = radius * 2 + 1;
        float[] kernel = createGaussianKernel(size);
        BufferedImage temp = new BufferedImage(source.getWidth(), source.getHeight(), BufferedImage.TYPE_INT_ARGB);
        BufferedImage result = new BufferedImage(source.getWidth(), source.getHeight(), BufferedImage.TYPE_INT_ARGB);

        // Apply horizontal blur
        convolve(source, temp, kernel, size, 1, 0);

        // Apply vertical blur
        convolve(temp, result, kernel, size, 0, 1);

        return result;
    }

    private float[] createGaussianKernel(int size) {
        float[] kernel = new float[size];
        float sigma = size / 3f;
        float sum = 0;
        int radius = size / 2;

        for (int i = 0; i < size; i++) {
            float x = i - radius;
            kernel[i] = (float) Math.exp(-(x * x) / (2 * sigma * sigma));
            sum += kernel[i];
        }

        // Normalize the kernel
        for (int i = 0; i < size; i++) {
            kernel[i] /= sum;
        }

        return kernel;
    }

    private void convolve(BufferedImage source, BufferedImage result, float[] kernel, int size, int dx, int dy) {
        int width = source.getWidth();
        int height = source.getHeight();
        int radius = size / 2;

        for (int y = 0; y < height; y++) {
            for (int x = 0; x < width; x++) {
                float r = 0, g = 0, b = 0, a = 0;
                for (int k = -radius; k <= radius; k++) {
                    int sampleX = x + k * dx;
                    int sampleY = y + k * dy;
                    if (sampleX >= 0 && sampleX < width && sampleY >= 0 && sampleY < height) {
                        int argb = source.getRGB(sampleX, sampleY);
                        float weight = kernel[k + radius];

                        a += ((argb >> 24) & 0xFF) * weight;
                        r += ((argb >> 16) & 0xFF) * weight;
                        g += ((argb >> 8) & 0xFF) * weight;
                        b += (argb & 0xFF) * weight;
                    }
                }
                int ia = Math.min(255, Math.max(0, (int) a));
                int ir = Math.min(255, Math.max(0, (int) r));
                int ig = Math.min(255, Math.max(0, (int) g));
                int ib = Math.min(255, Math.max(0, (int) b));

                result.setRGB(x, y, (ia << 24) | (ir << 16) | (ig << 8) | ib);
            }
        }
    }

    // Getters and setters for shadow size and color
    public int getShadowSize() {
        return shadowSize;
    }

    public void setShadowSize(int shadowSize) {
        this.shadowSize = shadowSize;
        shadowImage = null; // Clear cache
        repaint();
    }

    public Color getShadowColor() {
        return shadowColor;
    }

    public void setShadowColor(Color shadowColor) {
        this.shadowColor = shadowColor;
        shadowImage = null; // Clear cache
        repaint();
    }

    // Getter for colorStart
    public Color getColorStart() {
        return colorStart;
    }

    // Setter for colorStart
    public void setColorStart(Color colorStart) {
        Color oldColorStart = this.colorStart;
        this.colorStart = colorStart;
        pcs.firePropertyChange("colorStart", oldColorStart, colorStart);
        repaint();  // Repaint the panel to reflect the color change
    }

    // Getter for colorEnd
    public Color getColorEnd() {
        return colorEnd;
    }

    // Setter for colorEnd
    public void setColorEnd(Color colorEnd) {
        Color oldColorEnd = this.colorEnd;
        this.colorEnd = colorEnd;
        pcs.firePropertyChange("colorEnd", oldColorEnd, colorEnd);
        repaint();  // Repaint the panel to reflect the color change
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
